<h1 align="center">第 1 章 算法在计算中的作用</h1>

## 算法

**算法**

> **算法（algorithm）**是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法就是把输入转换成输出的计算步骤的一个序列。
> 
> 用于求解良说明的计算问题的工具。

**问题陈述/形式说明**

> 问题陈述说明了期望的输入/输出关系。算法则描述一个特定的过程时限输入/输出关系。
>
> 以将一个数列非递减排序问题为例：
>
> - **输入**：{%math%}n{%endmath%} 个数的一个序列 {%math%}\langle a_1,\ a_2, \ \cdots,\ a_n \rangle{%endmath%}
> - **输出**：输入序列的一个排列 {%math%} \langle a_1',\ a_2',\ \cdots,\ a_n' \rangle{%endmath%}，满足 ![](https://latex.vimsky.com/test.image.latex.php?fmt=svg&val=\inline \dpi{150} \footnotesize a_1' \leqslant a_2' \leqslant \cdots \leqslant a_n'&dl=0)

**问题实例**

> 问题的一个具体例子，由计算该问题解所必须的满足问题陈述中强加的各种约束的输入组成。

**排序算法的好坏依赖于**

> 将被排序的项数；这些项已被稍微排序的成都；关于项值的可能限制；计算机的体系结构；将使用的存储设备种类（主存、磁盘或者磁带）

**正确算法**

> 对每个输入实例算法都以正确的输出停机，则称算法是正确的。
> 
> 不正确的算法只要其错误率可控有时可能是有用的。

**算法的描述**

> 算法可以用日常语言说明，也可以说明成计算机程序，甚至说明为硬件设计。唯一的要求是这个说明必须精确描述所要遵循的计算过程

**一些算法问题**

> - 给定平面上的 {%math%} n {%endmath%} 个点，寻找这些点的凸壳。**凸壳**就是包含这些点的最小的凸多边形。
> - 给定一张交通图，上面标记了每对相邻十字路口之间的距离，我们希望确定从一个十字路口到另一个十字路口的最短道路。

有趣算法的特点

> 存在许多候选解，但大多数没有解决手头的问题，寻找一个真正的解或一个最好的解可能是个挑战；存在实际应用。

数据结构

> 存储和组织数据的方式，旨在便于访问和修改

算法设计与分析的技术

> 也许某天遇到一个问题，一时无法很快找到一个已有的算法解决它，这时这些技术可以帮助自行设计算法、证明其正确性、理解其效率

**难题**

> 不知道有效算法的 **NP 完全问题**。
> 
> > NP 完全问题：是否存在有效算法未知；任何一个 NP 完全问题有有效算法，所有 NP 完全问题由有效算法；有几个 NP 完全问题类似于一些有着已知有效算法的问题
> 
> NP 完全问题会时不时的在实际应用中出现。如果要找一个 NP 完全问题的有效算法，可能会话费许多时间在毫无结果的探寻种。如果能证明这个问题是 NP 完全的，那么可以把时间花在开发一个有效的算法，该算法给出一个好的解，但不一定是最好的可能解。
> 
> 一个 NP 完全问题的例子：**旅行商问题**
> 
> 一个投递公司具有一个中心仓库，每天在中心仓库为每辆车装货并发送出去，以将货物投递到几个地址。每天结束时每辆车必须回到仓库，以便第二天的送货。为了减少成本，公司希望选择投递站的一个序，按此序产生每辆车行驶的最短总距离。

并行性

> 功率密度随时钟速度超线性的增加，时钟速度足够快芯片将有熔化的危险，所以芯片被设计成多核，设计算法时必须考虑并行性

### 练习

**1.1-1、现实的排序、凸壳例子**

答：排序：考试成绩、时间管理时事情先做后做、瓶子中装石头石子沙子水、自助餐吃东西先后、走亲戚时顺序；凸壳：？

**1.1-2、除速度外现实中的有关效率的量度**

答：比热容、功率、加速度

**1.1-3、选择一种你以前已知的数据结构，并讨论其优势和局限**

答：列表，他可以很方便的找到指定位置的元素，但是要找到某个元素的位置是很麻烦的

**1.1-4、前面给出的最短路径与旅行商问题有哪些相似之处？又有哪些不同？**

答：相似之处：都想求最短距离；不同：最短路径是一辆车、不返回，旅行商问题是多辆车，要返回。

**1.1-5、提供一个现实中的问题，其中只有最佳解才行。再提供一个问题，近似最佳的一个解也足够好。**

答：成绩的排序，必须有最佳解，第一第二可不能错；找零钱算法，不一定非要算出最最少张数的找零方式，只要能让张数很少那就可用了。

## 作为一种技术的算法

假设计算机无限快且存储器免费，还有什么理由研究算法？即使仅仅因为想证明算法能以正确的答案停止，那么回答也是肯定的。

**效率**

针对相同问题的不同算法在效率方面常具有显著的差别，这些差别可能比由于硬件和软件造成的差别要重要得多。

例如用于排序的两个算法：插入排序和归并排序。

**插入排序**为了排序 {%math%}n{%endmath%} 个项，所花时间大致等于 {%math%}c_1 n^2{%endmath%} ，其中 {%math%}c_1{%endmath%} 是一个不依赖于 {%math%}n{%endmath%} 的常数。**归并排序**所花时间大致等于 {%math%}c_2 n \lg n{%endmath%}，其中 {%math%}\lg n{%endmath%} 代表 {%math%} \log_2n{%endmath%} 且 {%math%}c_2{%endmath%} 代表的是另一个不依赖于 {%math%}n{%endmath%} 的常数。

与归并排序相比，插入排序通常具有一个较小的常数因子，所以 {%math%}c_1 < c_2{%endmath%}。接下来将看到对运行时间来说，常数因子远没有对输入规模 {%math%}n{%endmath%} 的依赖性重要。（例如，两个公式的差别在于 {%math%}n{%endmath%} 和 {%math%}\lg n{%endmath%}，当 {%math%}n=1000{%endmath%} 时，{%math%}\lg n{%endmath%} 大致为 10，当 {%math%}n{%endmath%} 等于 100 万时，{%math%}\lg n{%endmath%} 大致仅为 20）。虽然对于小的输入规模，插入排序通常比归并排序快，但输入规模 n 变得足够大，{%math%}\lg n{%endmath%} 对 {%math%}n{%endmath%} 的优点将足以弥补常数因子的差别，不管 {%math%} c_1 {%endmath%} 比 {%math%}c_2{%endmath%} 小多少，总会存在一个交叉点，超出这个点归并排序更快。

更具体的举例，假设在每秒执行百亿条指令的计算机 A 上运行插入排序，在每秒仅执行 1000 万条指令的计算机 B 上运行归并排序。且为插入排序安排最好的程序员，写出只需要 {%math%}2n^2{%endmath%} 条指令的程序，而另一程序员为归并排序写出了需要 {%math%} 50n\lg n {%endmath%} 条指令的程序。为了排序 1000 万个数，计算机 A 需要

$$
\frac{2 \cdot (10^7)^2 \text{条指令}}{10^{10} \text{条指令每秒}} = 20000 \text{秒(多余 5.5 小时)}
$$

而计算机 B 需要

$$
\frac{50 \cdot 10^7 \lg 10^7 \text{条指令}}{10^7 \text{条指令/秒}} \approx 1163 \text{秒(少于 20 分钟)}
$$

用 Python 计算
```eval-python
import math

print(2 * (10**7)**2 / 10**10)
print(50 * 10**7 * math.log(10**7, 2) / 10** 7)
```

通过使用一个运行时间增长较慢的算法，即使编译器差，还快了 17 倍！如果排序 1 亿个数那优势会更加明显。随着问题规模的增大，归并排序的相对优势也会增大。

**算法与其他技术**

我们应该像计算机硬件一样把算法看成是一种**技术**。系统的性能不仅依赖于硬件而且依赖于算法。

许多应用需要算法，如一个基于万维网的旅行导向服务，寻找路线、描绘地图、插入地址等需要算法。

某些应用层不需要，但是会依赖于硬件、图形界面、网络、编译等，这些都需要算法。

以后随着计算机能力不断增强，要解决更大的问题，正如前例，此时算法的重要性更加突出。

### 练习

**1.2-1、应用层需要算法的例子，讨论涉及的算法的功能**

答：英雄联盟中的英雄移动，是一个寻路算法，在一个面上有很多路，路很宽人物可以来回走（点很小/真实路径很细），找寻最快到达目的地的路径。

**1.2-2、假设对规模为 {%math%}n{%endmath%} 的输入，插入排序运行 {%math%}8n^2{%endmath%} 步，归并排序需要 {%math%}64n\lg n{%endmath%} 步。对于哪些 {%math%}n{%endmath%} 使得插入排序优于归并排序？**

答：2～43 都可以。

{% graph %}
{
    "title": "两个函数图像（蓝色 8n^2）",
    "grid": true,
    "xAxis": {
        "domain": [-5, 45]
    },
    "yAxis": {
        "domain": [-500, 18000]
    },
    "data": [
        {
            "fn": "8 * x^2",
            "closed": false
        },
        {
            "fn": "64 * x * (log(x)/log(2))",
            "closed": false
        }
    ]
}
{% endgraph %}

```eval-python
# 这两个函数肯定有两个交点
# n=1 的时候对数为 0 的更小，n=2 时就被 64 影响更大了，所以从 2 开始判断，到 n^2 占据主要作用时结束
import math

def f1(n):
    return 8 * n**2


def f2(n):
    return 64 * n * math.log(n, 2)


num = 2
while 1:
    if f1(num) < f2(num):
        num += 1
    else:
        print num - 1
        break
```

**1.2-3、{%math%}n{%endmath%} 的最小值为多少时，运行时间为 {%math%}100n^2{%endmath%} 的一个算法在相同机器上快于 {%math%}2^n{%endmath%} 的另一个算法？**

答：15（0 其实更小，但排序空列表不是我们想要的）

```eval-python
def f1(n):
    return 100 * n**2


def f2(n):
    return 2 ** n


num = 1
while 1:
    if f1(num) < f2(num):
        break
    num += 1

print(num)
```

## 思考题

**1-1、（运行时间的比较）假设求解问题的算法需要 {%math%}f(n){%endmath%} 毫秒，对下表中的每个函数 {%math%}f(n) {%endmath%} 和时间 {%math%}t{%endmath%}，确定可以在时间 {%math%}t{%endmath%} 内求解的问题的最大规模 {%math%}n{%endmath%}**

{%math%}f(n){%endmath%}    | 1 秒钟 | 1 分钟  |  1 小时   |    1 天    |     1 月     |     1 年      |     1 世纪
:--------------------------|:------:|:-------:|:---------:|:----------:|:------------:|:-------------:|:--------------:
{%math%}\lg n{%endmath%}   | 2^1000 | 2^60000 | 2^3600000 | 2^86400000 | 2^2592000000 | 2^31536000000 | 2^3155673600000
{%math%}\sqrt n{%endmath%} | 1000^2 | 60000^2 | 3600000^2 | 86400000^2 | 2592000000^2 | 31536000000^2 | 3155673600000^2
{%math%}n{%endmath%}       |  1000  |  60000  |  3600000  |  86400000  |  2592000000  |  31536000000  |  3155673600000
{%math%}n \lg n{%endmath%} |  140   |  4895   |  204094   |  3943234   |   97659289   |  1052224334   |   86842987896
{%math%}n^2{%endmath%}     |   31   |   244   |   1897    |    9295    |    50911     |    177583     |     1776421
{%math%}n^3{%endmath%}     |   10   |   39    |    153    |    442     |     1373     |     3159      |      14667
{%math%}2^n{%endmath%}     |   9    |   15    |    21     |     26     |      31      |      34       |       41
{%math%}n!{%endmath%}      |   6    |    8    |     9     |     11     |      12      |      13       |       15

```eval-python
import math


def find_max_num(fn, target):
    num = 1
    while 1:
        if fn(num) > target:
            break
        num *= 2
    l, r = num / 2, num
    while l < r:
        mid = (l + r) // 2
        if fn(mid) <= target:
            l = mid + 1
        else:
            r = mid

    return r-1


fns = [
    # log 的增长太慢了，math 的开方小数位数不够用会出现不精确的结果
    # 正好前三个都很好算，直接口算就行了
    # lambda n: math.log(n, 2),
    # lambda n: math.sqrt(n),
    # lambda n: n,
    lambda n: n * math.log(n, 2),
    lambda n: n ** 2,
    lambda n: n ** 3,
    lambda n: 2 ** n,
    lambda n: math.factorial(n)
]
tgs = [
    1000,
    1000 * 60,
    1000 * 60 * 60,
    1000 * 60 * 60 * 24,
    1000 * 60 * 60 * 24 * 30,
    1000 * 60 * 60 * 24 * 365,
    1000 * 60 * 60 * 24 * 36524
]

res = [[str(find_max_num(fn, tg)) for tg in tgs] for fn in fns]

print('\n'.join(' | '.join(i) for i in res))
```
