<h1 align="center">第 2 章 算法基础</h1>

伪代码；算法正确性证明；分析算法运行时间；分治法；

## 插入排序

**排序问题**：

> - **输入**：{%math%}n{%endmath%} 个数的一个序列 {%math%}\langle a_1,\ a_2, \ \cdots,\ a_n \rangle{%endmath%}
> - **输出**：输入序列的一个排列 {%math%} \langle a_1',\ a_2',\ \cdots,\ a_n' \rangle{%endmath%}，满足 ![](https://latex.vimsky.com/test.image.latex.php?fmt=svg&val=\inline \dpi{150} \footnotesize a_1' \leqslant a_2' \leqslant \cdots \leqslant a_n'&dl=0)

希望排序的数也称为**关键词**

**伪代码**

> 伪代码中使用最清晰、最简洁的表示方法来说明给定的算法，不关心软件工程问题，忽略数据抽象、模块性和错误处理的问题
> 
> 有时最清晰的表示方法是自然语言，所以可能会有一个自然语言中的词语或橘子嵌入在一段伪代码中

**插入排序**

> 对少量元素很有效的算法
> 
> 扑克牌解释插入排序：
> 开始时左手为空且桌上的牌面朝下。每次从桌上拿走一张牌，并放到左手中正确的位置。为了找到正确的位置，从右到左将它与手中的每张牌比较。这样，拿在手中的牌总是排序好的，且这些牌原来是桌子上牌堆顶的牌。


### 伪代码

> 用以说明给定的算法

我们将伪代码过程命名为 INSERTION-SORT，一个参数是数组 A[1..n]，包含长度为 n 的要排序的一个序列。在算法结束时，输入数组 A 包含排好序的输出序列

**原址排序**
 
 > 插入排序原址排序输入的数：算法在数组 A 中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。

```py:INSERTION-SORT(A)
for j = 2 to A.length
    key = A[j]
    // 把 A[j] 插入到排好序的序列 A[1..j-1] 中去
    i = j - 1
    while i > 0 and A[i] > key
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
```

### 循环不变式

> 用以证明算法的正确性

下图（书图2-2）说明了对 {%math%}A = \langle 5,\ 2,\ 4,\ 6,\ 1,\ 3 \rangle{%endmath%} 上述算法如何工作

![image](https://user-images.githubusercontent.com/37435717/84749746-f6718980-afec-11ea-8556-cff6555d940e.png)

j 指出正被插入到手中的“当前牌”，每次 for 循环的开始，A[1..j-1] 构成了排好序的左手中的牌。我们把 A[1..j-1] 的这种性质表示为一个**循环不变式**：*在第 1～8 行的 **for** 循环的每次迭代开始时，子数组 A[1..j-1] 由原来在 A[1..j-1] 中的元素构成，但已按序排列。*（循环不变式的描述）

要声明循环不变式，必须证明下面三条性质成立（循环不变式的性质/条件）

- **初始化**：循环的第一次迭代之前，它为真
- **保持**：如果循环的某次迭代之前它为真，那么下次迭代之前它仍未真
- **终止**：在循环终止时，不变式提供一个有用的性质来帮助证明算法是正确的

当前两条性质成立时，在循环的每次迭代之前循环不变式为真，类似于数学归纳法。与归纳法不同的是归纳会无限使用下去，而循环不变式的第三条性质是要停止来证明算法的正确性。

插入排序的循环不变式性质：

- 初始化：第一次循环之前，j=2，子数组 A[1..j-1] 是由一个元素 A[1] 构成，当然有序，成立
- 保持：**for** 循环体的 4～7 行将 A[j] 左侧的元素向右移动一个位置，直到找到 A[j] 的位置，在 8 行将 A[j] 插入该位置。这时子数组 A[1..j] 由原来在 A[1..j] 中的元素构成，但已按序排列，成立
- 终止：循环终止条件是 j > A.lenght = n，那么 j=n+1，代入循环不变式的描述，子数组 A[1..n] 由原阿里在 A[1..n] 中元素组成，但已按序排列。而 A[1..n] 就是整个数组，因此算法正确

### 伪代码中的一些约定

- 缩进表示块结构
- **while**、**for** 与 **repeat-unitl** 等循环结构以及 **if-else** 等条件结构与常见编程语言中的结构具有类似的解释。
    - 推出循环后，循环计数器保持其值
    - 循环每次迭代增加其循环计数器时，使用关键词 **to**，减少时使用 **downto**，步长大于 1 时使用 **by**
- `//` 表示注释
- `i = j = e` 表示 `j = e` 后跟着 `i = j`
- 变量是局部的
- 数组元素通过“数组名[下标]”访问。A[1..j] 表示 A 的一个子数组，包含 A[1]，A[2]，…，A[j]
- 复合数据常组织成对象，对象由属性组成。
    - 数组或对象的变量是一个指针。对对象 x 的属性 f，赋值 y=x 导致 y.f 等于 x.f，若置 x.f=3，则 y.f 也等于 3
    - 指针不指向任何对象时，赋值 NIL
- 按值把参数传递给过程
    - 当对象被传递时，其指针被复制
- **return** 语句立即控制返回到调用过程的调用点，允许在 **return** 中返回多个值
- 布尔运算符“and”和“or”都是**短路**的
- 关键词 **error** 表示错误，调用过程负责处理被调用过程的错误

### 练习

**2.1-1、以图 2-2 为模型，说明 INSERTION-SORT 在数组 {%math%}A = \langle 31,\ 41,\ 59,\ 26,\ 41,\ 58 \rangle{%endmath%} 上的执行过程**

<style>
#g{background:#CCFF99}
#a{background:#99CCFF}
</style>

答：用绿表示要向右移动的值，蓝色表示要插入的值
0. [31, 41, 59, 26, 41, 58]
1. [31, <span id="a">41</span>, 59, 26, 41, 58]
2. [31, 41, <span id="a">59</span>, 26, 41, 58]
3. [<span id="g">31</span>, <span id="g">41</span>, <span id="g">59</span>, <span id="a">26</span>, 41, 58]
4. [26, 31, 41, <span id="g">59</span>, <span id="a">41</span>, 58]
5. [26, 31, 41, 41, <span id="g">59</span>, <span id="a">58</span>]
6. [26, 31, 41, 41, 58, 59]

**2.1-2、重写 INSERTION-SORT 过程，使之按非升序排列**

答：
```py:INSERTION-SORT-DESC(A)
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] < A[j]
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
```

要注意的点：while 判断的 i>0，最后赋值的 A[i+1]

**2.1-3、查找问题：根据下面输入输出写出线性查找的伪代码，它扫描整个序列来查找 v。使用循环不变式证明算法正确性。确保循环不变式满足三条必要的性质。**

- 输入：n 个数的一个序列 {%math%}A= \langle a_1,\ a_2,\ \cdots,\ a_n \rangle{%endmath%} 和一个值 v
- 输出：下标 i 使得 v=A[i] 或者当 v 不在 A 中出现时，i 为特殊值 NIL

答：
```py
i = NIL
for j = 1 to A.length
    if A.length[j] == v
        i = j
        break
```

循环不变式：每次迭代开始时，i 代表了 A[1..j-1] 中值等于 v 的元素的位置

- 初始化：开始时 j=1，A[1..0] 是空的，v 不等于其中任何值，i=NIL，成立
- 保持：**for** 循环体判断当前元素的值是否等于 v，如果等于就将 i 更新为当前元素的位置，否则不做任何改变。这样不论改变与否，i 都能继续代表 A[1..j-1] 中值等于 v 的元素的位置
- 终止：当找到值为 v 或者找完整个序列时终止，找到时 i 的值就是我们想要的，找完都没有时 i=NIV 也是符合预期的结果

**4、把两个 n 位二进制整数加起来，两个整数分别存储在两个 n 元数组 A 和 B 中。这两个整数的和应该按二进制形式存储在一个 (n+1) 元数组 C 中。给出问题的形式化描述，并写出伪代码**

答：

- 输入：n 位二进制数 {%math%}A=\langle a_1,\ a_2,\ \cdots,\ a_n \rangle\ (a_i \in N, a_i < 2){%endmath%} 和 {%math%}B=\langle b_1,\ b_2,\ \cdots,\ b_n \rangle\ (b_i \in N, b_i < 2>){%endmath%}
- 输出：n+1 位二进制数 {%math%}C=A+B=\langle c_1,\ c_2,\ \cdots,\ c_3\rangle\ (c_i \in N, c_i < 2){%endmath%}

伪代码
```py
C = [0] * (A.length + 1)
more = 0
for i = A.length downto 1
    sum = A[i] + B[i] + more
    if sum >= 2
        sum = sum - 2
        more = 1
    else
        more = 0
    C[i+1] = sum
C[1] = more
```

注意 sum 需要进位有 2、3 两种情况

## 分析算法

**随机访问机**

单处理器计算模型——随机访问机（random-access machine，RAM）。
在 RAM 模型中，指令一条条执行，没有并发操作。
RAM 模型包含算术指令（加、减、乘、除、取余、向下取整、向上取整）、数据移动指令（装入、存储、复制）、控制指令（条件与无条件转移、子程序调用与返回）且每条指令所需时间为常量。
当处理规模为 n 的输入时，一般假定整数由 {%math%}c \lg n{%endmath%} 位来表示（c 为大于等于 1 的常量），这样每个字都可以保存 n 的值。
对于小的正整数 k，将 {%math%}2^k{%endmath%} 看作是常量时间的操作。

### 插入排序算法的分析

**输入规模**：输入规模的最佳概念依赖于研究的问题。对排序来说是输入中的项数，对整数相乘来说是二进制表示输入所需的位数，对输入是图的算法来说是图中的顶点数和边数（两个数）

**运行时间**：执行的基本操作数或步数

下面由繁到简地改进 INSERTION-SORT 运行时间的表达式。假定第 i 行每次执行需要时间 {%math%}c_i{%endmath%}，{%math%}t_j{%endmath%} 表示对应 j 那个值的 **while** 循环中执行的次数。那么有：

![image](https://user-images.githubusercontent.com/37435717/84877847-972e7a80-b0bb-11ea-874a-c09d74e11559.png)

那么算法的运行时间是所有步骤运行时间之和

$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5 \sum_{j=2}^nt_j + c_6 \sum_{j=2}^n(t_j-1) + c_7 \sum_{j=2}^n(t_j-1) + c_8(n-1)
$$

**对于给定规模的情况，不同输入也会导致不同的运行时间。**

下面讨论插入排序的最佳情况与最快情况。

在插入排序中，如果输入已经排序，就是最佳的情况，这时对于每个 j，在第 5 行时都有 A[i] 小于等于 key，此时 6、7 行都不会运行。

$$
\begin{aligned}
T(n) 
&= c_1n + c_2(n-1) + c_4(n-1) + c_5(n-1) + c_8(n-1)\\
&= (c_1 + c_2 + c_4 + c_5 + c_8)n - (c_2+c_4+c_5+c_8)
\end{aligned}
$$

上面这个运行时间可以简化为 an+b，常量 a、b 依赖于 {%math%}c_i{%endmath%}。它是 n 的**线性函数**

当输入数组已经反向排序时，会有最坏情况，第 j 个元素必须与整个 A[1..j-1] 进行比较才行，所以 {%math%}t_j=j{%endmath%}。再根据 {%math%}\sum_{j=2}^nj=\frac{n(n+1)}2-1 {%endmath%} 和 {%math%}\sum_{j=2}^n(j-1)=\frac{n(n-1)}2 {%endmath%}，可以得到

$$
\begin{aligned}
T(n)
&=c_1n + c_2(n-1) + c_4(n-1) + c_5(\frac{n(n+1)}{2}-1) + c_6(\frac{n(n-1)}{2}) + c_7(\frac{n(n-1)}{2}) + c_8(n-1)\\
&=(\frac{c_5}{2} + \frac{c_6}{2} + \frac{c_7}{2})n^2 + (c_1 + c_2 + c_4 + \frac{c_5}{2} - \frac{c_6}{2} - \frac{c_7}{2} + c_8)n - (c_2 + c_4 + c_5 + c_8)
\end{aligned}
$$

那么可以将其简化为 {%math%}an^2 + bn + c{%endmath%}，其中常量 a、b、c 依赖于 {%math%}c_i{%endmath%}，它是**二次函数**。

虽然有些“随机化”算法，即使对于固定的输入行为也会变化，但通常是像插入排序这样，算法的运行时间对于给定的输入是固定的。

### 最坏情况与平均情况分析

本书集中于只求**最坏情况运行时间**，理由：

- 最坏情况运行时间给出了任何输入的运行时间的上界，确保算法不会需要更长时间，不必对运行时间作出复杂的预测且可以知道它不会变得更坏
- 对某些算法，最坏情况经常出现。比如数据库查询不存在的特定信息
- “平均情况”常与最坏情况大致一样差，例如插入排序的平均情况的运行时间也是输入规模的二次函数

### 增长量级/增长率

从最终的公式可以看到，用 a、b、c 不仅忽略了实际的语句代价，也忽略了抽象的代价 {%math%}c_j{%endmath%}。再向前一步，可以忽略低阶项和最高阶项的常系数，此时对插入排序的最坏情况来说，就剩下了 {%math%}n^2{%endmath%}，记为 {%math%}\Theta(n^2) {%endmath%}（暂时非形式化的使用 {%math%}\Theta{%endmath%}）

对足够大的输入规模，算法的增长量级越低越有效。

### 练习

**2.2-1、用 {%math%}\Theta{%endmath%} 记号表示函数 {%math%}n^3/1000-100n^2-100n+3{%endmath%}**

答：{%math%}\Theta(n^3){%endmath%}

**2.2-2、选择排序：找出 A 中最小的元素并将其与 A[1] 中元素互换，然后找出 A 中次最小元素并将其与 A[2] 中元素互换，对 A 中前 n-1 个元素按该方式继续。写出其伪代码；给出其循环不变式；只需要对前 n-1 个元素运行的原因？用 {%math%}\Theta{%endmath%} 记号给出最好情况与最坏情况运行时间**

答：

伪代码
```py
for i = 1 to A.length - 1
    min = i
    for j = i to A.length
        if A[j] < A[min]
            min = j
    tem = A[i]
    A[i] = A[min]
    A[min] = tem
```

循环不变式：每次第 1 行后的循环体开始前，A[1..i-1] 中存储了 A 中前 i-1 个最小的值，且按序排列

当 i = A.length = n 时退出循环，根据循环不变式可得，A[1..n-1] 中催出了 A 中前 n-1 个最小的值，且按序排列。那么此时 A[n] 就是最大的值，理应放在最右侧，此时整个 A 是有序的。

最好最坏情况都是 {%math%}\Theta(n^2){%endmath%}

**2.2-3、对于练习 [2.1-3](#练习)，假设要查找的元素等可能的为数组中任意元素，平均需要检查如数序列的多少元素？最坏情况如何？用 {%math%}\Theta{%endmath%} 记号给出线性查找的平均情况和最坏情况运行时间。证明之。**

答：平均要检查 n/2 个元素。最坏要查询 n 个。平均和最坏情况都是 {%math%}\Theta(n){%endmath%}

证明：假设第 i 行代码需要代价为 {%math%}c_i{%endmath%}。平均情况为查找到中间后找到，那么 {%math%}T(n) = c_1 + c_2\frac{n}{2} + c_3\frac{n}{2} + c_4 + c_5{%endmath%}，可以简化为 T(n) = an + b，则为 {%math%}\Theta(n){%endmath%}。最坏情况为找到最后时才查到，此时 {%math%}T(n) = c_1 + c_2n + c_3n + c_4 + c_5{%endmath%}，可以简化为 T(n) = an + b，则为 {%math%}\Theta(n){%endmath%}。

**2.2-4 可以如何修改几乎任何算法来使之具有良好的最好情况运行时间？**

答：可以加一个检查来直接拿到最佳情况，但是怎么加得视情况而定

## 设计算法

### 分治法

## 思考题