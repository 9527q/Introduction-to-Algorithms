<h1 align="center">第 2 章 算法基础</h1>

伪代码；算法正确性证明；分析算法运行时间；分治法；

## 插入排序

**排序问题**：

> - **输入**：{%math%}n{%endmath%} 个数的一个序列 {%math%}\langle a_1,\ a_2, \ \cdots,\ a_n \rangle{%endmath%}
> - **输出**：输入序列的一个排列 {%math%} \langle a_1',\ a_2',\ \cdots,\ a_n' \rangle{%endmath%}，满足 ![](https://latex.vimsky.com/test.image.latex.php?fmt=svg&val=\inline \dpi{150} \footnotesize a_1' \leqslant a_2' \leqslant \cdots \leqslant a_n'&dl=0)

希望排序的数也称为**关键词**

**伪代码**

> 伪代码中使用最清晰、最简洁的表示方法来说明给定的算法，不关心软件工程问题，忽略数据抽象、模块性和错误处理的问题
> 
> 有时最清晰的表示方法是自然语言，所以可能会有一个自然语言中的词语或橘子嵌入在一段伪代码中

**插入排序**

> 对少量元素很有效的算法
> 
> 扑克牌解释插入排序：
> 开始时左手为空且桌上的牌面朝下。每次从桌上拿走一张牌，并放到左手中正确的位置。为了找到正确的位置，从右到左将它与手中的每张牌比较。这样，拿在手中的牌总是排序好的，且这些牌原来是桌子上牌堆顶的牌。


### 伪代码

> 用以说明给定的算法

我们将伪代码过程命名为 INSERTION-SORT，一个参数是数组 A[1..n]，包含长度为 n 的要排序的一个序列。在算法结束时，输入数组 A 包含排好序的输出序列

**原址排序**
 
 > 插入排序原址排序输入的数：算法在数组 A 中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。

```py:INSERTION-SORT(A)
for j = 2 to A.length
    key = A[j]
    // 把 A[j] 插入到排好序的序列 A[1..j-1] 中去
    i = j - 1
    while i > 0 and A[i] > key
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
```

### 循环不变式

> 用以证明算法的正确性

下图（书图2-2）说明了对 {%math%}A = \langle 5,\ 2,\ 4,\ 6,\ 1,\ 3 \rangle{%endmath%} 上述算法如何工作

![image](https://user-images.githubusercontent.com/37435717/84749746-f6718980-afec-11ea-8556-cff6555d940e.png)

j 指出正被插入到手中的“当前牌”，每次 for 循环的开始，A[1..j-1] 构成了排好序的左手中的牌。我们把 A[1..j-1] 的这种性质表示为一个**循环不变式**：*在第 1～8 行的 **for** 循环的每次迭代开始时，子数组 A[1..j-1] 由原来在 A[1..j-1] 中的元素构成，但已按序排列。*（循环不变式的描述）

要声明循环不变式，必须证明下面三条性质成立（循环不变式的性质/条件）

- **初始化**：循环的第一次迭代之前，它为真
- **保持**：如果循环的某次迭代之前它为真，那么下次迭代之前它仍未真
- **终止**：在循环终止时，不变式提供一个有用的性质来帮助证明算法是正确的

当前两条性质成立时，在循环的每次迭代之前循环不变式为真，类似于数学归纳法。与归纳法不同的是归纳会无限使用下去，而循环不变式的第三条性质是要停止来证明算法的正确性。

插入排序的循环不变式性质：

- 初始化：第一次循环之前，j=2，子数组 A[1..j-1] 是由一个元素 A[1] 构成，当然有序，成立
- 保持：**for** 循环体的 4～7 行将 A[j] 左侧的元素向右移动一个位置，直到找到 A[j] 的位置，在 8 行将 A[j] 插入该位置。这时子数组 A[1..j] 由原来在 A[1..j] 中的元素构成，但已按序排列，成立
- 终止：循环终止条件是 j > A.lenght = n，那么 j=n+1，代入循环不变式的描述，子数组 A[1..n] 由原阿里在 A[1..n] 中元素组成，但已按序排列。而 A[1..n] 就是整个数组，因此算法正确

### 伪代码中的一些约定

- 缩进表示块结构
- **while**、**for** 与 **repeat-unitl** 等循环结构以及 **if-else** 等条件结构与常见编程语言中的结构具有类似的解释。
    - 推出循环后，循环计数器保持其值
    - 循环每次迭代增加其循环计数器时，使用关键词 **to**，减少时使用 **downto**，步长大于 1 时使用 **by**
- `//` 表示注释
- `i = j = e` 表示 `j = e` 后跟着 `i = j`
- 变量是局部的
- 数组元素通过“数组名[下标]”访问。A[1..j] 表示 A 的一个子数组，包含 A[1]，A[2]，…，A[j]
- 复合数据常组织成对象，对象由属性组成。
    - 数组或对象的变量是一个指针。对对象 x 的属性 f，赋值 y=x 导致 y.f 等于 x.f，若置 x.f=3，则 y.f 也等于 3
    - 指针不指向任何对象时，赋值 NIL
- 按值把参数传递给过程
    - 当对象被传递时，其指针被复制
- **return** 语句立即控制返回到调用过程的调用点，允许在 **return** 中返回多个值
- 布尔运算符“and”和“or”都是**短路**的
- 关键词 **error** 表示错误，调用过程负责处理被调用过程的错误

### 练习

**1、以图 2-2 为模型，说明 INSERTION-SORT 在数组 {%math%}A = \langle 31,\ 41,\ 59,\ 26,\ 41,\ 58 \rangle{%endmath%} 上的执行过程**

<style>
#g{background:#CCFF99}
#a{background:#99CCFF}
</style>

答：用绿表示要向右移动的值，蓝色表示要插入的值
0. [31, 41, 59, 26, 41, 58]
1. [31, <span id="a">41</span>, 59, 26, 41, 58]
2. [31, 41, <span id="a">59</span>, 26, 41, 58]
3. [<span id="g">31</span>, <span id="g">41</span>, <span id="g">59</span>, <span id="a">26</span>, 41, 58]
4. [26, 31, 41, <span id="g">59</span>, <span id="a">41</span>, 58]
5. [26, 31, 41, 41, <span id="g">59</span>, <span id="a">58</span>]
6. [26, 31, 41, 41, 58, 59]

**2、重写 INSERTION-SORT 过程，使之按非升序排列**

答：
```py:INSERTION-SORT-DESC(A)
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] < A[j]
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
```

要注意的点：while 判断的 i>0，最后赋值的 A[i+1]

**3、查找问题：根据下面输入输出写出线性查找的伪代码，它扫描整个序列来查找 v。使用循环不变式证明算法正确性。确保循环不变式满足三条必要的性质。**

- 输入：n 个数的一个序列 {%math%}A= \langle a_1,\ a_2,\ \cdots,\ a_n \rangle{%endmath%} 和一个值 v
- 输出：下标 i 使得 v=A[i] 或者当 v 不在 A 中出现时，i 为特殊值 NIL

答：
```py
i = NIL
for j = 1 to A.length
    if A.length[j] == v
        i = j
        break
```

循环不变式：每次迭代开始时，i 代表了 A[1..j-1] 中值等于 v 的元素的位置

- 初始化：开始时 j=1，A[1..0] 是空的，v 不等于其中任何值，i=NIL，成立
- 保持：**for** 循环体判断当前元素的值是否等于 v，如果等于就将 i 更新为当前元素的位置，否则不做任何改变。这样不论改变与否，i 都能继续代表 A[1..j-1] 中值等于 v 的元素的位置
- 终止：当找到值为 v 或者找完整个序列时终止，找到时 i 的值就是我们想要的，找完都没有时 i=NIV 也是符合预期的结果

**4、把两个 n 位二进制整数加起来，两个整数分别存储在两个 n 元数组 A 和 B 中。这两个整数的和应该按二进制形式存储在一个 (n+1) 元数组 C 中。给出问题的形式化描述，并写出伪代码**

答：

- 输入：n 位二进制数 {%math%}A=\langle a_1,\ a_2,\ \cdots,\ a_n \rangle\ (a_i \in N, a_i < 2){%endmath%} 和 {%math%}B=\langle b_1,\ b_2,\ \cdots,\ b_n \rangle\ (b_i \in N, b_i < 2>){%endmath%}
- 输出：n+1 位二进制数 {%math%}C=A+B=\langle c_1,\ c_2,\ \cdots,\ c_3\rangle\ (c_i \in N, c_i < 2){%endmath%}

伪代码
```py
C = [0] * (A.length + 1)
more = 0
for i = A.length downto 1
    sum = A[i] + B[i] + more
    if sum >= 2
        sum = sum - 2
        more = 1
    else
        more = 0
    C[i+1] = sum
C[1] = more
```

注意 sum 需要进位有 2、3 两种情况

## 分析算法

## 思考题