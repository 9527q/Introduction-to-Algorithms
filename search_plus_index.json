{"./":{"url":"./","title":"《算法导论》","keywords":"","body":"《算法导论》《Introduction to Algorithms》 第 3 版 本书提供了对当代计算机算法研究的一个全面、综合性的介绍。 这本书选材与时俱进，具有实用性；采用伪代码，即简洁易懂又便于抓住本质，还有丰富的插图描述算法过程，方便教学也便于自学；对算法正确性和复杂度的分析比较全面，既有严密的论证，又有直观的解释；既有结论性知识的介绍，也有逐步导出结论的过程；丰富的练习题和思考题使得及时检验所学知识和进一步拓展学习内容成为可能。 全书包含 957 道练习和 158 道思考题。 各个章节相对独立且由浅入深，建议在教学上将相对容易的入门性内容留在本科阶段，将相对难的较深入的内容放入研究生课程。更适合研究生的章节和习题前都加了 * 标志，不一定更难，但可能要了解更多的数学知识。 各个章节都是相对独立的，每一章都是以节为单位由易到难，完全可以单独选某一章进行学习。 配套网址上有一些练习和思考题的答案，以及一些已知错误。 练习中带有 * 号的更适合研究生做。 基础知识 第 1 章 算法在计算机中的作用 第 2 章 算法基础 排序和顺序统计量 数据结构 高级设计和分析技术 高级数据结构 图算法 算法问题选编 附录：数学基础知识 TODO [ ] 第一章凸壳的例子 [x] gitbook 增加 latex 支持 powered by Gitbook更新时间： 2020-06-12 21:59:48 "},"part1.html":{"url":"part1.html","title":"基础知识","keywords":"","body":"第一部分 基础知识 引导读者思考算法的设计和分析问题，简单介绍算法的表达方法、将在书中用到的设计策略，算法分析中用到的许多基本思想 第 1 章 算法在计算中的作用 powered by Gitbook更新时间： 2020-06-12 21:59:48 "},"chapter1.html":{"url":"chapter1.html","title":"第 1 章 算法在计算机中的作用","keywords":"","body":"第 1 章 算法在计算中的作用 算法 算法 算法（algorithm）是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法就是把输入转换成输出的计算步骤的一个序列。 用于求解良说明的计算问题的工具。 问题实例 问题的一个具体例子，由计算该问题解所必须的满足问题陈述中强加的各种约束的输入组成。 排序算法的好坏依赖于 将被排序的项数；这些项已被稍微排序的成都；关于项值的可能限制；计算机的体系结构；将使用的存储设备种类（主存、磁盘或者磁带） 正确算法 对每个输入实例算法都以正确的输出停机，则称算法是正确的。 不正确的算法只要其错误率可控有时可能是有用的。 算法的描述 算法可以用日常语言说明，也可以说明成计算机程序，甚至说明为硬件设计。唯一的要求是这个说明必须精确描述所要遵循的计算过程 一些算法问题 给定平面上的 n n n 个点，寻找这些点的凸壳。凸壳就是包含这些点的最小的凸多边形。 给定一张交通图，上面标记了每对相邻十字路口之间的距离，我们希望确定从一个十字路口到另一个十字路口的最短道路。 有趣算法的特点 存在许多候选解，但大多数没有解决手头的问题，寻找一个真正的解或一个最好的解可能是个挑战；存在实际应用。 数据结构 存储和组织数据的方式，旨在便于访问和修改 算法设计与分析的技术 也许某天遇到一个问题，一时无法很快找到一个已有的算法解决它，这时这些技术可以帮助自行设计算法、证明其正确性、理解其效率 难题 不知道有效算法的 NP 完全问题。 NP 完全问题：是否存在有效算法未知；任何一个 NP 完全问题有有效算法，所有 NP 完全问题由有效算法；有几个 NP 完全问题类似于一些有着已知有效算法的问题 NP 完全问题会时不时的在实际应用中出现。如果要找一个 NP 完全问题的有效算法，可能会话费许多时间在毫无结果的探寻种。如果能证明这个问题是 NP 完全的，那么可以把时间花在开发一个有效的算法，该算法给出一个好的解，但不一定是最好的可能解。 一个 NP 完全问题的例子：旅行商问题 一个投递公司具有一个中心仓库，每天在中心仓库为每辆车装货并发送出去，以将货物投递到几个地址。每天结束时每辆车必须回到仓库，以便第二天的送货。为了减少成本，公司希望选择投递站的一个序，按此序产生每辆车行驶的最短总距离。 并行性 功率密度随时钟速度超线性的增加，时钟速度足够快芯片将有熔化的危险，所以芯片被设计成多核，设计算法时必须考虑并行性 练习 1、现实的排序、凸壳例子 答：排序：考试成绩、时间管理时事情先做后做、瓶子中装石头石子沙子水、自助餐吃东西先后、走亲戚时顺序；凸壳：？ 2、除速度外现实中的有关效率的量度 答：比热容、功率、加速度 3、选择一种你以前已知的数据结构，并讨论其优势和局限 答：列表，他可以很方便的找到指定位置的元素，但是要找到某个元素的位置是很麻烦的 4、前面给出的最短路径与旅行商问题有哪些相似之处？又有哪些不同？ 答：相似之处：都想求最短距离；不同：最短路径是一辆车、不返回，旅行商问题是多辆车，要返回。 5、提供一个现实中的问题，其中只有最佳解才行。再提供一个问题，近似最佳的一个解也足够好。 答：成绩的排序，必须有最佳解，第一第二可不能错；找零钱算法，不一定非要算出最最少张数的找零方式，只要能让张数很少那就可用了。 作为一种技术的算法 假设计算机无限快且存储器免费，还有什么理由研究算法？即使仅仅因为想证明算法能以正确的答案停止，那么回答也是肯定的。 效率 针对相同问题的不同算法在效率方面常具有显著的差别，这些差别可能比由于硬件和软件造成的差别要重要得多。 例如用于排序的两个算法：插入排序和归并排序。 插入排序为了排序 nnn 个项，所花时间大致等于 c1n2c_1 n^2c​1​​n​2​​ ，其中 c1c_1c​1​​ 是一个不依赖于 nnn 的常数。归并排序所花时间大致等于 c2nlgnc_2 n \\lg nc​2​​nlgn，其中 lgn\\lg nlgn 代表 log2n \\log_2nlog​2​​n 且 c2c_2c​2​​ 代表的是另一个不依赖于 nnn 的常数。 与归并排序相比，插入排序通常具有一个较小的常数因子，所以 c1c2c_1 c​1​​c​2​​。接下来将看到对运行时间来说，常数因子远没有对输入规模 nnn 的依赖性重要。（例如，两个公式的差别在于 nnn 和 lgn\\lg nlgn，当 n=1000n=1000n=1000 时，lgn\\lg nlgn 大致为 10，当 nnn 等于 100 万时，lgn\\lg nlgn 大致仅为 20）。虽然对于小的输入规模，插入排序通常比归并排序快，但输入规模 n 变得足够大，lgn\\lg nlgn 对 nnn 的优点将足以弥补常数因子的差别，不管 c1 c_1 c​1​​ 比 c2c_2c​2​​ 小多少，总会存在一个交叉点，超出这个点归并排序更快。 更具体的举例，假设在每秒执行百亿条指令的计算机 A 上运行插入排序，在每秒仅执行 1000 万条指令的计算机 B 上运行归并排序。且为插入排序安排最好的程序员，写出只需要 2n22n^22n​2​​ 条指令的程序，而另一程序员为归并排序写出了需要 50nlgn 50n\\lg n 50nlgn 条指令的程序。为了排序 1000 万个数，计算机 A 需要 2⋅(107)2条指令1010条指令每秒=20000秒(多余 5.5 小时) \\frac{2 \\cdot (10^7)^2 \\text{条指令}}{10^{10} \\text{条指令每秒}} = 20000 \\text{秒(多余 5.5 小时)} ​10​10​​条指令每秒​​2⋅(10​7​​)​2​​条指令​​=20000秒(多余 5.5 小时) 而计算机 B 需要 50⋅107lg107条指令107条指令/秒≈1163秒(少于 20 分钟) \\frac{50 \\cdot 10^7 \\lg 10^7 \\text{条指令}}{10^7 \\text{条指令/秒}} \\approx 1163 \\text{秒(少于 20 分钟)} ​10​7​​条指令/秒​​50⋅10​7​​lg10​7​​条指令​​≈1163秒(少于 20 分钟) 用 Python 计算 import math print(2 * (10**7)**2 / 10**10) print(50 * 10**7 * math.log(10**7, 2) / 10** 7) 通过使用一个运行时间增长较慢的算法，即使编译器差，还快了 17 倍！如果排序 1 亿个数那优势会更加明显。随着问题规模的增大，归并排序的相对优势也会增大。 算法与其他技术 我们应该像计算机硬件一样把算法看成是一种技术。系统的性能不仅依赖于硬件而且依赖于算法。 许多应用需要算法，如一个基于万维网的旅行导向服务，寻找路线、描绘地图、插入地址等需要算法。 某些应用层不需要，但是会依赖于硬件、图形界面、网络、编译等，这些都需要算法。 以后随着计算机能力不断增强，要解决更大的问题，正如前例，此时算法的重要性更加突出。 练习 1、应用层需要算法的例子，讨论涉及的算法的功能 答：英雄联盟中的英雄移动，是一个寻路算法，在一个面上有很多路，路很宽人物可以来回走（点很小/真实路径很细），找寻最快到达目的地的路径。 2、假设对规模为 nnn 的输入，插入排序运行 8n28n^28n​2​​ 步，归并排序需要 64nlgn64n\\lg n64nlgn 步。对于哪些 nnn 使得插入排序优于归并排序？ 答：2～43 都可以。 functionPlot({\"title\":\"两个函数图像（蓝色 8n^2）\",\"grid\":true,\"xAxis\":{\"domain\":[-5,45]},\"yAxis\":{\"domain\":[-500,18000]},\"data\":[{\"fn\":\"8 * x^2\",\"closed\":false},{\"fn\":\"64 * x * (log(x)/log(2))\",\"closed\":false}],\"target\":\"#plugin-graph-0\"}); # 这两个函数肯定有两个交点 # n=1 的时候对数为 0 的更小，n=2 时就被 64 影响更大了，所以从 2 开始判断，到 n^2 占据主要作用时结束 import math def f1(n): return 8 * n**2 def f2(n): return 64 * n * math.log(n, 2) num = 2 while 1: if f1(num) 3、nnn 的最小值为多少时，运行时间为 100n2100n^2100n​2​​ 的一个算法在相同机器上快于 2n2^n2​n​​ 的另一个算法？ 答：15（0 其实更小，但排序空列表不是我们想要的） def f1(n): return 100 * n**2 def f2(n): return 2 ** n num = 1 while 1: if f1(num) 思考题 1、（运行时间的比较）假设求解问题的算法需要 f(n)f(n)f(n) 毫秒，对下表中的每个函数 f(n)f(n) f(n) 和时间 ttt，确定可以在时间 ttt 内求解的问题的最大规模 nnn f(n)f(n)f(n) 1 秒钟 1 分钟 1 小时 1 天 1 月 1 年 1 世纪 lgn\\lg nlgn 2^1000 2^60000 2^3600000 2^86400000 2^2592000000 2^31536000000 2^3155673600000 n\\sqrt n√​n​​​ 1000^2 60000^2 3600000^2 86400000^2 2592000000^2 31536000000^2 3155673600000^2 nnn 1000 60000 3600000 86400000 2592000000 31536000000 3155673600000 nlgnn \\lg nnlgn 140 4895 204094 3943234 97659289 1052224334 86842987896 n2n^2n​2​​ 31 244 1897 9295 50911 177583 1776421 n3n^3n​3​​ 10 39 153 442 1373 3159 14667 2n2^n2​n​​ 9 15 21 26 31 34 41 n!n!n! 6 8 9 11 12 13 15 import math def find_max_num(fn, target): num = 1 while 1: if fn(num) > target: break num *= 2 l, r = num / 2, num while l powered by Gitbook更新时间： 2020-06-12 22:04:44 "}}