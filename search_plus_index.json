{"./":{"url":"./","title":"《算法导论》","keywords":"","body":"《算法导论》《Introduction to Algorithms》 第 3 版 算法导论又叫 CLRS，来源于四位作者的名字首字母 Thomas H. Cormen，Charles E. Leiserson，Ronald L. Rivest，Clifford Stein 本书提供了对当代计算机算法研究的一个全面、综合性的介绍。 这本书选材与时俱进，具有实用性；采用伪代码，即简洁易懂又便于抓住本质，还有丰富的插图描述算法过程，方便教学也便于自学；对算法正确性和复杂度的分析比较全面，既有严密的论证，又有直观的解释；既有结论性知识的介绍，也有逐步导出结论的过程；丰富的练习题和思考题使得及时检验所学知识和进一步拓展学习内容成为可能。 全书包含 957 道练习和 158 道思考题。 各个章节相对独立且由浅入深，建议在教学上将相对容易的入门性内容留在本科阶段，将相对难的较深入的内容放入研究生课程。更适合研究生的章节和习题前都加了 * 标志，不一定更难，但可能要了解更多的数学知识。 各个章节都是相对独立的，每一章都是以节为单位由易到难，完全可以单独选某一章进行学习。 配套网址上有一些练习和思考题的答案，以及一些已知错误。 部分习题答案 刊误 一个习题解答仓库 练习中带有 * 号的更适合研究生做。 基础知识 第 1 章 算法在计算机中的作用 第 2 章 算法基础 排序和顺序统计量 数据结构 高级设计和分析技术 高级数据结构 图算法 算法问题选编 附录：数学基础知识 TODO [ ] 第一章凸壳的例子 [x] gitbook 增加 latex 支持 powered by Gitbook更新时间： 2020-06-17 15:10:48 "},"part1.html":{"url":"part1.html","title":"基础知识","keywords":"","body":"第一部分 基础知识 引导读者思考算法的设计和分析问题，简单介绍算法的表达方法、将在书中用到的设计策略，算法分析中用到的许多基本思想 第 1 章 算法在计算中的作用 第 2 章 算法基础 powered by Gitbook更新时间： 2020-06-16 18:31:57 "},"chapter1.html":{"url":"chapter1.html","title":"第 1 章 算法在计算机中的作用","keywords":"","body":"第 1 章 算法在计算中的作用 算法 算法 算法（algorithm）是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法就是把输入转换成输出的计算步骤的一个序列。 用于求解良说明的计算问题的工具。 问题陈述/形式说明 问题陈述说明了期望的输入/输出关系。算法则描述一个特定的过程时限输入/输出关系。 以将一个数列非递减排序问题为例： 输入：nnn 个数的一个序列 ⟨a1, a2, ⋯, an⟩\\langle a_1,\\ a_2, \\ \\cdots,\\ a_n \\rangle⟨a​1​​, a​2​​, ⋯, a​n​​⟩ 输出：输入序列的一个排列 ⟨a1′, a2′, ⋯, an′⟩ \\langle a_1',\\ a_2',\\ \\cdots,\\ a_n' \\rangle⟨a​1​′​​, a​2​′​​, ⋯, a​n​′​​⟩，满足 问题实例 问题的一个具体例子，由计算该问题解所必须的满足问题陈述中强加的各种约束的输入组成。 排序算法的好坏依赖于 将被排序的项数；这些项已被稍微排序的成都；关于项值的可能限制；计算机的体系结构；将使用的存储设备种类（主存、磁盘或者磁带） 正确算法 对每个输入实例算法都以正确的输出停机，则称算法是正确的。 不正确的算法只要其错误率可控有时可能是有用的。 算法的描述 算法可以用日常语言说明，也可以说明成计算机程序，甚至说明为硬件设计。唯一的要求是这个说明必须精确描述所要遵循的计算过程 一些算法问题 给定平面上的 n n n 个点，寻找这些点的凸壳。凸壳就是包含这些点的最小的凸多边形。 给定一张交通图，上面标记了每对相邻十字路口之间的距离，我们希望确定从一个十字路口到另一个十字路口的最短道路。 有趣算法的特点 存在许多候选解，但大多数没有解决手头的问题，寻找一个真正的解或一个最好的解可能是个挑战；存在实际应用。 数据结构 存储和组织数据的方式，旨在便于访问和修改 算法设计与分析的技术 也许某天遇到一个问题，一时无法很快找到一个已有的算法解决它，这时这些技术可以帮助自行设计算法、证明其正确性、理解其效率 难题 不知道有效算法的 NP 完全问题。 NP 完全问题：是否存在有效算法未知；任何一个 NP 完全问题有有效算法，所有 NP 完全问题由有效算法；有几个 NP 完全问题类似于一些有着已知有效算法的问题 NP 完全问题会时不时的在实际应用中出现。如果要找一个 NP 完全问题的有效算法，可能会话费许多时间在毫无结果的探寻种。如果能证明这个问题是 NP 完全的，那么可以把时间花在开发一个有效的算法，该算法给出一个好的解，但不一定是最好的可能解。 一个 NP 完全问题的例子：旅行商问题 一个投递公司具有一个中心仓库，每天在中心仓库为每辆车装货并发送出去，以将货物投递到几个地址。每天结束时每辆车必须回到仓库，以便第二天的送货。为了减少成本，公司希望选择投递站的一个序，按此序产生每辆车行驶的最短总距离。 并行性 功率密度随时钟速度超线性的增加，时钟速度足够快芯片将有熔化的危险，所以芯片被设计成多核，设计算法时必须考虑并行性 练习 1.1-1、现实的排序、凸壳例子 答：排序：考试成绩、时间管理时事情先做后做、瓶子中装石头石子沙子水、自助餐吃东西先后、走亲戚时顺序；凸壳：？ 1.1-2、除速度外现实中的有关效率的量度 答：比热容、功率、加速度 1.1-3、选择一种你以前已知的数据结构，并讨论其优势和局限 答：列表，他可以很方便的找到指定位置的元素，但是要找到某个元素的位置是很麻烦的 1.1-4、前面给出的最短路径与旅行商问题有哪些相似之处？又有哪些不同？ 答：相似之处：都想求最短距离；不同：最短路径是一辆车、不返回，旅行商问题是多辆车，要返回。 1.1-5、提供一个现实中的问题，其中只有最佳解才行。再提供一个问题，近似最佳的一个解也足够好。 答：成绩的排序，必须有最佳解，第一第二可不能错；找零钱算法，不一定非要算出最最少张数的找零方式，只要能让张数很少那就可用了。 作为一种技术的算法 假设计算机无限快且存储器免费，还有什么理由研究算法？即使仅仅因为想证明算法能以正确的答案停止，那么回答也是肯定的。 效率 针对相同问题的不同算法在效率方面常具有显著的差别，这些差别可能比由于硬件和软件造成的差别要重要得多。 例如用于排序的两个算法：插入排序和归并排序。 插入排序为了排序 nnn 个项，所花时间大致等于 c1n2c_1 n^2c​1​​n​2​​ ，其中 c1c_1c​1​​ 是一个不依赖于 nnn 的常数。归并排序所花时间大致等于 c2nlgnc_2 n \\lg nc​2​​nlgn，其中 lgn\\lg nlgn 代表 log2n \\log_2nlog​2​​n 且 c2c_2c​2​​ 代表的是另一个不依赖于 nnn 的常数。 与归并排序相比，插入排序通常具有一个较小的常数因子，所以 c1c2c_1 c​1​​c​2​​。接下来将看到对运行时间来说，常数因子远没有对输入规模 nnn 的依赖性重要。（例如，两个公式的差别在于 nnn 和 lgn\\lg nlgn，当 n=1000n=1000n=1000 时，lgn\\lg nlgn 大致为 10，当 nnn 等于 100 万时，lgn\\lg nlgn 大致仅为 20）。虽然对于小的输入规模，插入排序通常比归并排序快，但输入规模 n 变得足够大，lgn\\lg nlgn 对 nnn 的优点将足以弥补常数因子的差别，不管 c1 c_1 c​1​​ 比 c2c_2c​2​​ 小多少，总会存在一个交叉点，超出这个点归并排序更快。 更具体的举例，假设在每秒执行百亿条指令的计算机 A 上运行插入排序，在每秒仅执行 1000 万条指令的计算机 B 上运行归并排序。且为插入排序安排最好的程序员，写出只需要 2n22n^22n​2​​ 条指令的程序，而另一程序员为归并排序写出了需要 50nlgn 50n\\lg n 50nlgn 条指令的程序。为了排序 1000 万个数，计算机 A 需要 2⋅(107)2条指令1010条指令每秒=20000秒(多余 5.5 小时) \\frac{2 \\cdot (10^7)^2 \\text{条指令}}{10^{10} \\text{条指令每秒}} = 20000 \\text{秒(多余 5.5 小时)} ​10​10​​条指令每秒​​2⋅(10​7​​)​2​​条指令​​=20000秒(多余 5.5 小时) 而计算机 B 需要 50⋅107lg107条指令107条指令/秒≈1163秒(少于 20 分钟) \\frac{50 \\cdot 10^7 \\lg 10^7 \\text{条指令}}{10^7 \\text{条指令/秒}} \\approx 1163 \\text{秒(少于 20 分钟)} ​10​7​​条指令/秒​​50⋅10​7​​lg10​7​​条指令​​≈1163秒(少于 20 分钟) 用 Python 计算 import math print(2 * (10**7)**2 / 10**10) print(50 * 10**7 * math.log(10**7, 2) / 10** 7) 通过使用一个运行时间增长较慢的算法，即使编译器差，还快了 17 倍！如果排序 1 亿个数那优势会更加明显。随着问题规模的增大，归并排序的相对优势也会增大。 算法与其他技术 我们应该像计算机硬件一样把算法看成是一种技术。系统的性能不仅依赖于硬件而且依赖于算法。 许多应用需要算法，如一个基于万维网的旅行导向服务，寻找路线、描绘地图、插入地址等需要算法。 某些应用层不需要，但是会依赖于硬件、图形界面、网络、编译等，这些都需要算法。 以后随着计算机能力不断增强，要解决更大的问题，正如前例，此时算法的重要性更加突出。 练习 1.2-1、应用层需要算法的例子，讨论涉及的算法的功能 答：英雄联盟中的英雄移动，是一个寻路算法，在一个面上有很多路，路很宽人物可以来回走（点很小/真实路径很细），找寻最快到达目的地的路径。 1.2-2、假设对规模为 nnn 的输入，插入排序运行 8n28n^28n​2​​ 步，归并排序需要 64nlgn64n\\lg n64nlgn 步。对于哪些 nnn 使得插入排序优于归并排序？ 答：2～43 都可以。 functionPlot({\"title\":\"两个函数图像（蓝色 8n^2）\",\"grid\":true,\"xAxis\":{\"domain\":[-5,45]},\"yAxis\":{\"domain\":[-500,18000]},\"data\":[{\"fn\":\"8 * x^2\",\"closed\":false},{\"fn\":\"64 * x * (log(x)/log(2))\",\"closed\":false}],\"target\":\"#plugin-graph-0\"}); # 这两个函数肯定有两个交点 # n=1 的时候对数为 0 的更小，n=2 时就被 64 影响更大了，所以从 2 开始判断，到 n^2 占据主要作用时结束 import math def f1(n): return 8 * n**2 def f2(n): return 64 * n * math.log(n, 2) num = 2 while 1: if f1(num) 1.2-3、nnn 的最小值为多少时，运行时间为 100n2100n^2100n​2​​ 的一个算法在相同机器上快于 2n2^n2​n​​ 的另一个算法？ 答：15（0 其实更小，但排序空列表不是我们想要的） def f1(n): return 100 * n**2 def f2(n): return 2 ** n num = 1 while 1: if f1(num) 思考题 1-1、（运行时间的比较）假设求解问题的算法需要 f(n)f(n)f(n) 毫秒，对下表中的每个函数 f(n)f(n) f(n) 和时间 ttt，确定可以在时间 ttt 内求解的问题的最大规模 nnn f(n)f(n)f(n) 1 秒钟 1 分钟 1 小时 1 天 1 月 1 年 1 世纪 lgn\\lg nlgn 2^1000 2^60000 2^3600000 2^86400000 2^2592000000 2^31536000000 2^3155673600000 n\\sqrt n√​n​​​ 1000^2 60000^2 3600000^2 86400000^2 2592000000^2 31536000000^2 3155673600000^2 nnn 1000 60000 3600000 86400000 2592000000 31536000000 3155673600000 nlgnn \\lg nnlgn 140 4895 204094 3943234 97659289 1052224334 86842987896 n2n^2n​2​​ 31 244 1897 9295 50911 177583 1776421 n3n^3n​3​​ 10 39 153 442 1373 3159 14667 2n2^n2​n​​ 9 15 21 26 31 34 41 n!n!n! 6 8 9 11 12 13 15 import math def find_max_num(fn, target): num = 1 while 1: if fn(num) > target: break num *= 2 l, r = num / 2, num while l powered by Gitbook更新时间： 2020-06-17 18:03:59 "},"chapter2.html":{"url":"chapter2.html","title":"第 2 章 算法基础","keywords":"","body":"第 2 章 算法基础 伪代码；算法正确性证明；分析算法运行时间；分治法； 插入排序 排序问题： 输入：nnn 个数的一个序列 ⟨a1, a2, ⋯, an⟩\\langle a_1,\\ a_2, \\ \\cdots,\\ a_n \\rangle⟨a​1​​, a​2​​, ⋯, a​n​​⟩ 输出：输入序列的一个排列 ⟨a1′, a2′, ⋯, an′⟩ \\langle a_1',\\ a_2',\\ \\cdots,\\ a_n' \\rangle⟨a​1​′​​, a​2​′​​, ⋯, a​n​′​​⟩，满足 希望排序的数也称为关键词 伪代码 伪代码中使用最清晰、最简洁的表示方法来说明给定的算法，不关心软件工程问题，忽略数据抽象、模块性和错误处理的问题 有时最清晰的表示方法是自然语言，所以可能会有一个自然语言中的词语或橘子嵌入在一段伪代码中 插入排序 对少量元素很有效的算法 扑克牌解释插入排序： 开始时左手为空且桌上的牌面朝下。每次从桌上拿走一张牌，并放到左手中正确的位置。为了找到正确的位置，从右到左将它与手中的每张牌比较。这样，拿在手中的牌总是排序好的，且这些牌原来是桌子上牌堆顶的牌。 伪代码 用以说明给定的算法 我们将伪代码过程命名为 INSERTION-SORT，一个参数是数组 A[1..n]，包含长度为 n 的要排序的一个序列。在算法结束时，输入数组 A 包含排好序的输出序列 原址排序 插入排序原址排序输入的数：算法在数组 A 中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。 INSERTION-SORT(A) for j = 2 to A.length key = A[j] // 把 A[j] 插入到排好序的序列 A[1..j-1] 中去 i = j - 1 while i > 0 and A[i] > key A[i+1] = A[i] i = i - 1 A[i+1] = key 循环不变式 用以证明算法的正确性 下图（书图2-2）说明了对 A=⟨5, 2, 4, 6, 1, 3⟩A = \\langle 5,\\ 2,\\ 4,\\ 6,\\ 1,\\ 3 \\rangleA=⟨5, 2, 4, 6, 1, 3⟩ 上述算法如何工作 j 指出正被插入到手中的“当前牌”，每次 for 循环的开始，A[1..j-1] 构成了排好序的左手中的牌。我们把 A[1..j-1] 的这种性质表示为一个循环不变式：在第 1～8 行的 for 循环的每次迭代开始时，子数组 A[1..j-1] 由原来在 A[1..j-1] 中的元素构成，但已按序排列。（循环不变式的描述） 要声明循环不变式，必须证明下面三条性质成立（循环不变式的性质/条件） 初始化：循环的第一次迭代之前，它为真 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍未真 终止：在循环终止时，不变式提供一个有用的性质来帮助证明算法是正确的 当前两条性质成立时，在循环的每次迭代之前循环不变式为真，类似于数学归纳法。与归纳法不同的是归纳会无限使用下去，而循环不变式的第三条性质是要停止来证明算法的正确性。 插入排序的循环不变式性质： 初始化：第一次循环之前，j=2，子数组 A[1..j-1] 是由一个元素 A[1] 构成，当然有序，成立 保持：for 循环体的 4～7 行将 A[j] 左侧的元素向右移动一个位置，直到找到 A[j] 的位置，在 8 行将 A[j] 插入该位置。这时子数组 A[1..j] 由原来在 A[1..j] 中的元素构成，但已按序排列，成立 终止：循环终止条件是 j > A.lenght = n，那么 j=n+1，代入循环不变式的描述，子数组 A[1..n] 由原阿里在 A[1..n] 中元素组成，但已按序排列。而 A[1..n] 就是整个数组，因此算法正确 伪代码中的一些约定 缩进表示块结构 while、for 与 repeat-unitl 等循环结构以及 if-else 等条件结构与常见编程语言中的结构具有类似的解释。 推出循环后，循环计数器保持其值 循环每次迭代增加其循环计数器时，使用关键词 to，减少时使用 downto，步长大于 1 时使用 by // 表示注释 i = j = e 表示 j = e 后跟着 i = j 变量是局部的 数组元素通过“数组名[下标]”访问。A[1..j] 表示 A 的一个子数组，包含 A[1]，A[2]，…，A[j] 复合数据常组织成对象，对象由属性组成。 数组或对象的变量是一个指针。对对象 x 的属性 f，赋值 y=x 导致 y.f 等于 x.f，若置 x.f=3，则 y.f 也等于 3 指针不指向任何对象时，赋值 NIL 按值把参数传递给过程 当对象被传递时，其指针被复制 return 语句立即控制返回到调用过程的调用点，允许在 return 中返回多个值 布尔运算符“and”和“or”都是短路的 关键词 error 表示错误，调用过程负责处理被调用过程的错误 练习 2.1-1、以图 2-2 为模型，说明 INSERTION-SORT 在数组 A=⟨31, 41, 59, 26, 41, 58⟩A = \\langle 31,\\ 41,\\ 59,\\ 26,\\ 41,\\ 58 \\rangleA=⟨31, 41, 59, 26, 41, 58⟩ 上的执行过程 #g{background:#CCFF99} #a{background:#99CCFF} 答：用绿表示要向右移动的值，蓝色表示要插入的值 [31, 41, 59, 26, 41, 58] [31, 41, 59, 26, 41, 58] [31, 41, 59, 26, 41, 58] [31, 41, 59, 26, 41, 58] [26, 31, 41, 59, 41, 58] [26, 31, 41, 41, 59, 58] [26, 31, 41, 41, 58, 59] 2.1-2、重写 INSERTION-SORT 过程，使之按非升序排列 答： INSERTION-SORT-DESC(A) for j = 2 to A.length key = A[j] i = j - 1 while i > 0 and A[i] 要注意的点：while 判断的 i>0，最后赋值的 A[i+1] 2.1-3、查找问题：根据下面输入输出写出线性查找的伪代码，它扫描整个序列来查找 v。使用循环不变式证明算法正确性。确保循环不变式满足三条必要的性质。 输入：n 个数的一个序列 A=⟨a1, a2, ⋯, an⟩A= \\langle a_1,\\ a_2,\\ \\cdots,\\ a_n \\rangleA=⟨a​1​​, a​2​​, ⋯, a​n​​⟩ 和一个值 v 输出：下标 i 使得 v=A[i] 或者当 v 不在 A 中出现时，i 为特殊值 NIL 答： i = NIL for j = 1 to A.length if A.length[j] == v i = j break 循环不变式：每次迭代开始时，i 代表了 A[1..j-1] 中值等于 v 的元素的位置 初始化：开始时 j=1，A[1..0] 是空的，v 不等于其中任何值，i=NIL，成立 保持：for 循环体判断当前元素的值是否等于 v，如果等于就将 i 更新为当前元素的位置，否则不做任何改变。这样不论改变与否，i 都能继续代表 A[1..j-1] 中值等于 v 的元素的位置 终止：当找到值为 v 或者找完整个序列时终止，找到时 i 的值就是我们想要的，找完都没有时 i=NIV 也是符合预期的结果 4、把两个 n 位二进制整数加起来，两个整数分别存储在两个 n 元数组 A 和 B 中。这两个整数的和应该按二进制形式存储在一个 (n+1) 元数组 C 中。给出问题的形式化描述，并写出伪代码 答： 输入：n 位二进制数 A=⟨a1, a2, ⋯, an⟩ (ai∈N,ai2)A=\\langle a_1,\\ a_2,\\ \\cdots,\\ a_n \\rangle\\ (a_i \\in N, a_i A=⟨a​1​​, a​2​​, ⋯, a​n​​⟩ (a​i​​∈N,a​i​​2) 和 B=⟨b1, b2, ⋯, bn⟩ (bi∈N,bi2>)B=\\langle b_1,\\ b_2,\\ \\cdots,\\ b_n \\rangle\\ (b_i \\in N, b_i )B=⟨b​1​​, b​2​​, ⋯, b​n​​⟩ (b​i​​∈N,b​i​​2>) 输出：n+1 位二进制数 C=A+B=⟨c1, c2, ⋯, c3⟩ (ci∈N,ci2)C=A+B=\\langle c_1,\\ c_2,\\ \\cdots,\\ c_3\\rangle\\ (c_i \\in N, c_i C=A+B=⟨c​1​​, c​2​​, ⋯, c​3​​⟩ (c​i​​∈N,c​i​​2) 伪代码 C = [0] * (A.length + 1) more = 0 for i = A.length downto 1 sum = A[i] + B[i] + more if sum >= 2 sum = sum - 2 more = 1 else more = 0 C[i+1] = sum C[1] = more 注意 sum 需要进位有 2、3 两种情况 分析算法 随机访问机 单处理器计算模型——随机访问机（random-access machine，RAM）。 在 RAM 模型中，指令一条条执行，没有并发操作。 RAM 模型包含算术指令（加、减、乘、除、取余、向下取整、向上取整）、数据移动指令（装入、存储、复制）、控制指令（条件与无条件转移、子程序调用与返回）且每条指令所需时间为常量。 当处理规模为 n 的输入时，一般假定整数由 clgnc \\lg nclgn 位来表示（c 为大于等于 1 的常量），这样每个字都可以保存 n 的值。 对于小的正整数 k，将 2k2^k2​k​​ 看作是常量时间的操作。 插入排序算法的分析 输入规模：输入规模的最佳概念依赖于研究的问题。对排序来说是输入中的项数，对整数相乘来说是二进制表示输入所需的位数，对输入是图的算法来说是图中的顶点数和边数（两个数） 运行时间：执行的基本操作数或步数 下面由繁到简地改进 INSERTION-SORT 运行时间的表达式。假定第 i 行每次执行需要时间 cic_ic​i​​，tjt_jt​j​​ 表示对应 j 那个值的 while 循环中执行的次数。那么有： 那么算法的运行时间是所有步骤运行时间之和 T(n)=c1n+c2(n−1)+c4(n−1)+c5∑j=2ntj+c6∑j=2n(tj−1)+c7∑j=2n(tj−1)+c8(n−1) T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5 \\sum_{j=2}^nt_j + c_6 \\sum_{j=2}^n(t_j-1) + c_7 \\sum_{j=2}^n(t_j-1) + c_8(n-1) T(n)=c​1​​n+c​2​​(n−1)+c​4​​(n−1)+c​5​​​j=2​∑​n​​t​j​​+c​6​​​j=2​∑​n​​(t​j​​−1)+c​7​​​j=2​∑​n​​(t​j​​−1)+c​8​​(n−1) 对于给定规模的情况，不同输入也会导致不同的运行时间。 下面讨论插入排序的最佳情况与最快情况。 在插入排序中，如果输入已经排序，就是最佳的情况，这时对于每个 j，在第 5 行时都有 A[i] 小于等于 key，此时 6、7 行都不会运行。 T(n)=c1n+c2(n−1)+c4(n−1)+c5(n−1)+c8(n−1)=(c1+c2+c4+c5+c8)n−(c2+c4+c5+c8) \\begin{aligned} T(n) &= c_1n + c_2(n-1) + c_4(n-1) + c_5(n-1) + c_8(n-1)\\\\ &= (c_1 + c_2 + c_4 + c_5 + c_8)n - (c_2+c_4+c_5+c_8) \\end{aligned} ​T(n)​​​​=c​1​​n+c​2​​(n−1)+c​4​​(n−1)+c​5​​(n−1)+c​8​​(n−1)​=(c​1​​+c​2​​+c​4​​+c​5​​+c​8​​)n−(c​2​​+c​4​​+c​5​​+c​8​​)​​ 上面这个运行时间可以简化为 an+b，常量 a、b 依赖于 cic_ic​i​​。它是 n 的线性函数 当输入数组已经反向排序时，会有最坏情况，第 j 个元素必须与整个 A[1..j-1] 进行比较才行，所以 tj=jt_j=jt​j​​=j。再根据 ∑j=2nj=n(n+1)2−1\\sum_{j=2}^nj=\\frac{n(n+1)}2-1 ∑​j=2​n​​j=​2​​n(n+1)​​−1 和 ∑j=2n(j−1)=n(n−1)2\\sum_{j=2}^n(j-1)=\\frac{n(n-1)}2 ∑​j=2​n​​(j−1)=​2​​n(n−1)​​，可以得到 T(n)=c1n+c2(n−1)+c4(n−1)+c5(n(n+1)2−1)+c6(n(n−1)2)+c7(n(n−1)2)+c8(n−1)=(c52+c62+c72)n2+(c1+c2+c4+c52−c62−c72+c8)n−(c2+c4+c5+c8) \\begin{aligned} T(n) &=c_1n + c_2(n-1) + c_4(n-1) + c_5(\\frac{n(n+1)}{2}-1) + c_6(\\frac{n(n-1)}{2}) + c_7(\\frac{n(n-1)}{2}) + c_8(n-1)\\\\ &=(\\frac{c_5}{2} + \\frac{c_6}{2} + \\frac{c_7}{2})n^2 + (c_1 + c_2 + c_4 + \\frac{c_5}{2} - \\frac{c_6}{2} - \\frac{c_7}{2} + c_8)n - (c_2 + c_4 + c_5 + c_8) \\end{aligned} ​T(n)​​​​=c​1​​n+c​2​​(n−1)+c​4​​(n−1)+c​5​​(​2​​n(n+1)​​−1)+c​6​​(​2​​n(n−1)​​)+c​7​​(​2​​n(n−1)​​)+c​8​​(n−1)​=(​2​​c​5​​​​+​2​​c​6​​​​+​2​​c​7​​​​)n​2​​+(c​1​​+c​2​​+c​4​​+​2​​c​5​​​​−​2​​c​6​​​​−​2​​c​7​​​​+c​8​​)n−(c​2​​+c​4​​+c​5​​+c​8​​)​​ 那么可以将其简化为 an2+bn+can^2 + bn + can​2​​+bn+c，其中常量 a、b、c 依赖于 cic_ic​i​​，它是二次函数。 虽然有些“随机化”算法，即使对于固定的输入行为也会变化，但通常是像插入排序这样，算法的运行时间对于给定的输入是固定的。 最坏情况与平均情况分析 本书集中于只求最坏情况运行时间，理由： 最坏情况运行时间给出了任何输入的运行时间的上界，确保算法不会需要更长时间，不必对运行时间作出复杂的预测且可以知道它不会变得更坏 对某些算法，最坏情况经常出现。比如数据库查询不存在的特定信息 “平均情况”常与最坏情况大致一样差，例如插入排序的平均情况的运行时间也是输入规模的二次函数 增长量级/增长率 从最终的公式可以看到，用 a、b、c 不仅忽略了实际的语句代价，也忽略了抽象的代价 cjc_jc​j​​。再向前一步，可以忽略低阶项和最高阶项的常系数，此时对插入排序的最坏情况来说，就剩下了 n2n^2n​2​​，记为 Θ(n2)\\Theta(n^2) Θ(n​2​​)（暂时非形式化的使用 Θ\\ThetaΘ） 对足够大的输入规模，算法的增长量级越低越有效。 练习 2.2-1、用 Θ\\ThetaΘ 记号表示函数 n3/1000−100n2−100n+3n^3/1000-100n^2-100n+3n​3​​/1000−100n​2​​−100n+3 答：Θ(n3)\\Theta(n^3)Θ(n​3​​) 2.2-2、选择排序：找出 A 中最小的元素并将其与 A[1] 中元素互换，然后找出 A 中次最小元素并将其与 A[2] 中元素互换，对 A 中前 n-1 个元素按该方式继续。写出其伪代码；给出其循环不变式；只需要对前 n-1 个元素运行的原因？用 Θ\\ThetaΘ 记号给出最好情况与最坏情况运行时间 答： 伪代码 for i = 1 to A.length - 1 min = i for j = i to A.length if A[j] 循环不变式：每次第 1 行后的循环体开始前，A[1..i-1] 中存储了 A 中前 i-1 个最小的值，且按序排列 当 i = A.length = n 时退出循环，根据循环不变式可得，A[1..n-1] 中催出了 A 中前 n-1 个最小的值，且按序排列。那么此时 A[n] 就是最大的值，理应放在最右侧，此时整个 A 是有序的。 最好最坏情况都是 Θ(n2)\\Theta(n^2)Θ(n​2​​) 2.2-3、对于练习 2.1-3，假设要查找的元素等可能的为数组中任意元素，平均需要检查如数序列的多少元素？最坏情况如何？用 Θ\\ThetaΘ 记号给出线性查找的平均情况和最坏情况运行时间。证明之。 答：平均要检查 n/2 个元素。最坏要查询 n 个。平均和最坏情况都是 Θ(n)\\Theta(n)Θ(n) 证明：假设第 i 行代码需要代价为 cic_ic​i​​。平均情况为查找到中间后找到，那么 T(n)=c1+c2n2+c3n2+c4+c5T(n) = c_1 + c_2\\frac{n}{2} + c_3\\frac{n}{2} + c_4 + c_5T(n)=c​1​​+c​2​​​2​​n​​+c​3​​​2​​n​​+c​4​​+c​5​​，可以简化为 T(n) = an + b，则为 Θ(n)\\Theta(n)Θ(n)。最坏情况为找到最后时才查到，此时 T(n)=c1+c2n+c3n+c4+c5T(n) = c_1 + c_2n + c_3n + c_4 + c_5T(n)=c​1​​+c​2​​n+c​3​​n+c​4​​+c​5​​，可以简化为 T(n) = an + b，则为 Θ(n)\\Theta(n)Θ(n)。 2.2-4 可以如何修改几乎任何算法来使之具有良好的最好情况运行时间？ 答：可以加一个检查来直接拿到最佳情况，但是怎么加得视情况而定 设计算法 分治法 思考题 powered by Gitbook更新时间： 2020-06-17 18:39:03 "}}